# This class represents a 1D Mesh
# TODO: it should be a composite of Element1D
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.pyplot import triplot
from scipy.sparse import lil_matrix
import math


def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2

    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors


class Mesh2D:

    def __init__(self, ne = 0, p = np.array([]), conn = np.array([])):
        print("Initializing Mesh 2D...")
        if conn.size != 0 and p.size != 0:
            print("Create from triangles")
        else:
            print("Define new mesh based on ne")
            self.ne = ne
            [p, conn] = self.construct()
        self.ne = len(conn)
        self.p = p
        self.conn = conn
        self.n_p = len(p)

    @staticmethod
    def find_balanced_couple(ne):
        rad = np.sqrt(ne)
        y = np.mod(rad, 1)
        A = 0
        B = 0
        if y == 0:
            A = B = int(rad)
        else:
            set_A = []
            set_B = []
            queue = get_prime_factors(ne)
            while queue:
                if np.prod(set_B) < np.prod(set_A):
                    set_B.append(queue.pop())
                else:
                    set_A.append(queue.pop())
                A = np.prod(set_A)
                B = np.prod(set_B)
        return int(A), int(B)

    def construct(self):
        [h_el, v_el] = self.find_balanced_couple(self.ne)
        ne = self.ne
        h_p = np.linspace(0, 1, num = h_el+1, endpoint = True)
        v_p = np.linspace(0, 1, num = v_el+1, endpoint = True)
        n_p = len(h_p) * len(v_p)
        p = []

        for v in v_p:
            for h in h_p:
                p.append([h, v])

        sq_conn = []
        k = 0
        z = 0
        for j in range(0, v_el):
            for i in range(0, h_el):
                sq_conn.append([k, k + 1, k + len(h_p) + 1, k + len(h_p)])
                k += 1
            k = z + len(h_p)
            z = z + len(h_p)

        conn = np.zeros((ne * 2, 3), dtype= int)
        k = 0
        for i in range(0, ne):
            square = sq_conn[i]
            conn[k, :] = [square[0], square[1], square[2]]
            conn[k + 1, :] = [square[0], square[2], square[3]]
            k = k + 2

        return np.array(p), conn

    def refine(self, regular = True):
        p = self.p
        conn = self.conn
        ne = len(conn)
        n_p = len(p)
        # mid - edges(i, j) contains 1 if the edge(i, j) already has a midpoint
        mid_edges = lil_matrix((n_p, n_p), dtype=np.int)

        # mid - coord(i, j) contains  the point of the midpoint of edge(i, j)
        mid_coord = lil_matrix((n_p, n_p))

        # each triangle is divided into 4 new triangles
        new_conn = np.zeros((ne * 4, 3), dtype=np.int)
        nm = 0  # element generated by refinement

        if regular:
            a = 0.5
            b = 0.5
        else:
            a = 0.3
            b = 1-a

        for j in range(0, ne):
            el = conn[j, :]

            # t_new contains the points forming the new triangle
            t_new = np.zeros((3, 1), dtype= int)

            # k loop over the 3 points of each triangle to work on each edge
            for k in range(0, len(el)):
                # left/right are the limit of each edge of the triangle j
                left = el[k]
                if k == len(el) - 1:
                    right = el[0]
                else:
                    right = el[k+1]

                # if point in middle of edge was not defined
                if mid_edges[left, right] == 0:
                    r = a + (b - a) * np.random.rand()
                    xn = r * p[left, 0] + (1 - r) * p[right, 0]
                    yn = r * p[left, 1] + (1 - r) * p[right, 1]
                    mid_edges[left, right] = 1
                    mid_coord[left, right] = n_p
                    mid_edges[right, left] = 1
                    mid_coord[right, left] = n_p
                    t_new[k] = n_p
                    p = np.vstack((p, [xn, yn]))
                    n_p = n_p + 1
                else:
                    # otherwise we just take already existing point
                    t_new[k] = mid_coord[left, right]

            # create new sub-elements
            new_conn[nm, :] = [t_new[0], el[1], t_new[1]]
            nm = nm + 1
            new_conn[nm, :] = [t_new[1], el[2], t_new[2]]
            nm = nm + 1
            new_conn[nm, :] = [t_new[0], t_new[1], t_new[2]]
            nm = nm + 1
            new_conn[nm, :] = [el[0], t_new[0], t_new[2]]
            nm = nm + 1

        self.p = p
        self.conn = new_conn
        self.n_p = len(p)

    def embedding(self):
        p = self.p
        conn = self.conn

        horizontal = 0
        vertical = 0
        n_p = self.get_np()
        for ii in range(0, 2):
            left_border = np.where(p[:, 0] == (0 - horizontal))[0]
            right_border = np.where(p[:, 0] == (1 + horizontal))[0]
            bottom_border = np.where(p[:, 1] == (0 - vertical))[0]
            top_border = np.where(p[:, 1] == (1 + vertical))[0]

            left_edge = np.ones((1, 2), dtype=int) * -1
            right_edge = np.ones((1, 2), dtype=int) * -1
            bottom_edge = np.ones((1, 2), dtype=int) * -1
            top_edge = np.ones((1, 2), dtype=int) * -1
            for el in conn:
                left_edge = self.find_edges(el, left_border, left_edge)
                right_edge = self.find_edges(el, right_border, right_edge)
                bottom_edge = self.find_edges(el, bottom_border, bottom_edge)
                top_edge = self.find_edges(el, top_border, top_edge)

            # Order edges - so that first in list is lowest(leftest), last is highest(rightest)
            left_edge = self.order_edges(left_edge, p, 1)
            bottom_edge = self.order_edges(bottom_edge, p, 0)
            right_edge = self.order_edges(right_edge, p, 1)
            top_edge = self.order_edges(top_edge, p, 0)

            # Find shift (horizontal or vertical) from edge based on border edges
            vertical = self.find_h_v_shift(p, [left_edge, right_edge], 1)
            horizontal = self.find_h_v_shift(p, [top_edge, bottom_edge], 0)


            # New Border Node creation
            new_p_left = np.zeros((left_border.shape[0], 2), dtype=int)
            new_p_left[:, 0] = left_border
            new_p_left[:, 1] = -1
            left_angles = np.zeros((2, 2), dtype=int)
            for i in range(0, len(left_edge)):
                edge = left_edge[i, :]
                p1 = edge[0]
                p2 = edge[1]
                coord1 = p[p1, :]
                coord2 = p[p2, :]
                if coord1[1] < coord2[1]:
                    top = edge[1]
                    down = edge[0]
                else:
                    top = edge[0]
                    down = edge[1]
                # Now, create or retrieve node on left of 'down', i.e, new_down
                pos = np.where(new_p_left[:, 0] == down)[0][0]
                if new_p_left[pos, 1] == -1:
                    new_p = [p[down, 0] - horizontal, p[down, 1]]
                    p = np.vstack((p, new_p))
                    new_p_left[pos, 1] = n_p
                    new_down = n_p
                    n_p = n_p + 1
                else:
                    new_down = new_p_left[pos, 1]
                if i == 0:
                    left_angles[0, :] = [down, new_down]
                # Now, create or retrieve node on left of 'top', i.e, new_top
                pos = np.where(new_p_left[:, 0] == top)[0][0]
                if new_p_left[pos, 1] == -1:
                    new_p = [p[top, 0] - horizontal, p[top, 1]]
                    p = np.vstack((p, new_p))
                    new_p_left[pos, 1] = n_p
                    new_top = n_p
                    n_p = n_p + 1
                else:
                    new_top = new_p_left[pos, 1]
                if i == len(left_edge) - 1:
                    left_angles[1, :] = [new_top, top]

                square = [new_down, down, top, new_top]
                conn = np.vstack((conn, [square[0], square[1], square[2]]))
                conn = np.vstack((conn, [square[0], square[2], square[3]]))

            new_p_right = np.zeros((right_border.shape[0], 2), dtype=int)
            new_p_right[:, 0] = right_border
            new_p_right[:, 1] = -1
            right_angles = np.zeros((2, 2), dtype=int)
            for i in range(0, len(right_edge)):
                edge = right_edge[i, :]
                p1 = edge[0]
                p2 = edge[1]
                coord1 = p[p1, :]
                coord2 = p[p2, :]
                if coord1[1] < coord2[1]:
                    top = edge[1]
                    down = edge[0]
                else:
                    top = edge[0]
                    down = edge[1]
                # Now, create or retrieve node on left of 'down', i.e, new_down
                pos = np.where(new_p_right[:, 0] == down)[0][0]
                if new_p_right[pos, 1] == -1:
                    new_p = [p[down, 0] + horizontal, p[down, 1]]
                    p = np.vstack((p, new_p))
                    new_p_right[pos, 1] = n_p
                    new_down = n_p
                    n_p = n_p + 1
                else:
                    new_down = new_p_right[pos, 1]
                if i == 0:
                    right_angles[0, :] = [new_down, down]
                # Now, create or retrieve node on left of 'top', i.e, new_top
                pos = np.where(new_p_right[:, 0] == top)[0][0]
                if new_p_right[pos, 1] == -1:
                    new_p = [p[top, 0] + horizontal, p[top, 1]]
                    p = np.vstack((p, new_p))
                    new_p_right[pos, 1] = n_p
                    new_top = n_p
                    n_p = n_p + 1
                else:
                    new_top = new_p_right[pos, 1]
                if i == len(right_edge) - 1:
                    right_angles[1, :] = [top, new_top]

                square = [down, new_down, new_top, top]
                conn = np.vstack((conn, [square[0], square[1], square[2]]))
                conn = np.vstack((conn, [square[0], square[2], square[3]]))

            new_p_bottom = np.zeros((bottom_border.shape[0], 2), dtype=int)
            new_p_bottom[:, 0] = bottom_border
            new_p_bottom[:, 1] = -1
            bottom_angles = np.zeros((2, 2), dtype=int)
            for i in range(0, len(bottom_edge)):
                edge = bottom_edge[i, :]
                p1 = edge[0]
                p2 = edge[1]
                coord1 = p[p1, :]
                coord2 = p[p2, :]
                if coord1[0] < coord2[0]:
                    left = edge[0]
                    right = edge[1]
                else:
                    left = edge[1]
                    right = edge[0]
                # Now, create or retrieve node on left of 'down', i.e, new_down
                pos = np.where(new_p_bottom[:, 0] == left)[0][0]
                if new_p_bottom[pos, 1] == -1:
                    new_p = [p[left, 0], p[left, 1] - vertical]
                    p = np.vstack((p, new_p))
                    new_p_bottom[pos, 1] = n_p
                    new_left = n_p
                    n_p = n_p + 1
                else:
                    new_left = new_p_bottom[pos, 1]
                if i == 0:
                    bottom_angles[0, :] = [new_left, left]
                # Now, create or retrieve node on left of 'top', i.e, new_top
                pos = np.where(new_p_bottom[:, 0] == right)[0][0]
                if new_p_bottom[pos, 1] == -1:
                    new_p = [p[right, 0], p[right, 1] - vertical]
                    p = np.vstack((p, new_p))
                    new_p_bottom[pos, 1] = n_p
                    new_right = n_p
                    n_p = n_p + 1
                else:
                    new_right = new_p_bottom[pos, 1]
                if i == len(bottom_edge) - 1:
                    bottom_angles[1, :] = [right, new_right]

                square = [new_left, new_right, right, left]
                conn = np.vstack((conn, [square[0], square[1], square[2]]))
                conn = np.vstack((conn, [square[0], square[2], square[3]]))

            new_p_top = np.zeros((top_border.shape[0], 2), dtype=int)
            new_p_top[:, 0] = top_border
            new_p_top[:, 1] = -1
            top_angles = np.zeros((2, 2), dtype=int)
            for i in range(0, len(top_edge)):
                edge = top_edge[i, :]
                p1 = edge[0]
                p2 = edge[1]
                coord1 = p[p1, :]
                coord2 = p[p2, :]
                if coord1[0] < coord2[0]:
                    left = edge[0]
                    right = edge[1]
                else:
                    left = edge[1]
                    right = edge[0]
                # Now, create or retrieve node on left of 'down', i.e, new_down
                pos = np.where(new_p_top[:, 0] == left)[0][0]
                if new_p_top[pos, 1] == -1:
                    new_p = [p[left, 0], p[left, 1] + vertical]
                    p = np.vstack((p, new_p))
                    new_p_top[pos, 1] = n_p
                    new_left = n_p
                    n_p = n_p + 1
                else:
                    new_left = new_p_top[pos, 1]
                if i == 0:
                    top_angles[0, :] = [left, new_left]
                # Now, create or retrieve node on left of 'top', i.e, new_top
                pos = np.where(new_p_top[:, 0] == right)[0][0]
                if new_p_top[pos, 1] == -1:
                    new_p = [p[right, 0], p[right, 1] + vertical]
                    p = np.vstack((p, new_p))
                    new_p_top[pos, 1] = n_p
                    new_right = n_p
                    n_p = n_p + 1
                else:
                    new_right = new_p_top[pos, 1]
                if i == len(top_edge) - 1:
                    top_angles[1, :] = [new_right, right]

                square = [left, right, new_right, new_left]
                conn = np.vstack((conn, [square[0], square[1], square[2]]))
                conn = np.vstack((conn, [square[0], square[2], square[3]]))

            # Create New Angle

            # angle left - bottom
            b = abs(np.diff(p[left_angles[0, :], 0]))
            x = p[left_angles[0, 0], 0] - b
            h = abs(np.diff(p[bottom_angles[0, :], 1]))
            y = p[bottom_angles[0, 1], 1] - h
            angle_lb = np.array([x[0], y[0]])
            p = np.vstack((p, angle_lb))
            square = [n_p, bottom_angles[0, 0], left_angles[0, 0], left_angles[0, 1]]
            conn = np.vstack((conn, [square[0], square[1], square[2]]))
            conn = np.vstack((conn, [square[0], square[2], square[3]]))
            n_p = n_p + 1

            # angle left - top
            b = abs(np.diff(p[left_angles[1, :], 0]))
            x = p[left_angles[0, 0], 0] - b
            h = abs(np.diff(p[top_angles[0, :], 1]))
            y = p[top_angles[0, 0], 1] + h
            angle_lt = np.array([x[0], y[0]])
            p = np.vstack((p, angle_lt))
            square = [left_angles[1, 0], left_angles[1, 1], top_angles[0, 1], n_p]
            conn = np.vstack((conn, [square[0], square[1], square[2]]))
            conn = np.vstack((conn, [square[0], square[2], square[3]]))
            n_p = n_p + 1

            # angle right - top
            b = abs(np.diff(p[right_angles[1, :], 0]))
            x = p[right_angles[1, 0], 0] + b
            h = abs(np.diff(p[top_angles[1, :], 1]))
            y = p[top_angles[1, 1], 1] + h
            angle_rt = np.array([x[0], y[0]])
            p = np.vstack((p, angle_rt))
            square = [top_angles[1, 1], right_angles[1, 1], n_p, top_angles[1, 0]]
            conn = np.vstack((conn, [square[0], square[1], square[2]]))
            conn = np.vstack((conn, [square[0], square[2], square[3]]))
            n_p = n_p + 1

            # angle right - bottom
            b = abs(np.diff(p[right_angles[0, :], 0]))
            x = p[right_angles[0, 1], 0] + b
            h = abs(np.diff(p[bottom_angles[1, :], 1]))
            y = p[bottom_angles[1, 0], 1] - h
            angle_rb = np.array([x[0], y[0]])
            p = np.vstack((p, angle_rb))
            square = [bottom_angles[1, 1], n_p, right_angles[0, 0], right_angles[0, 1]]
            conn = np.vstack((conn, [square[0], square[1], square[2]]))
            conn = np.vstack((conn, [square[0], square[2], square[3]]))
            n_p = n_p + 1

            del left_edge, right_edge, bottom_edge, top_edge
            del left_border, right_border, bottom_border, top_border

        embed = Mesh2D(p=p, conn=conn)
        return embed


    @staticmethod
    def find_h_v_shift(p, edges, index):
        l_len = 100
        for e in edges[0]:
            tmp = np.diff(p[e, index])
            if tmp < l_len:
                l_len = tmp
        r_len = 100
        for e in edges[1]:
            tmp = np.diff(p[e, index])
            if tmp < r_len:
                r_len = tmp
        shift = max(l_len, r_len)
        return shift[0]

    @staticmethod
    def order_edges(edge, p, axis):
        val_1 = min(p[edge[:, 0], axis])
        pos_1 = np.where(p[edge[:, 0], axis] == val_1)[0][0]
        val_2 = min(p[edge[:, 1], axis])
        pos_2 = np.where(p[edge[:, 1], axis] == val_2)[0][0]
        if val_1 < val_2:
            minim = pos_1
        else:
            minim = pos_2
        edge[[0, minim]] = edge[[minim, 0]]

        val_1 = max(p[edge[:, 0], axis])
        pos_1 = np.where(p[edge[:, 0], axis] == val_1)[0][0]
        val_2 = max(p[edge[:, 1], axis])
        pos_2 = np.where(p[edge[:, 1], axis] == val_2)[0][0]
        if val_1 > val_2:
            maxim = pos_1
        else:
            maxim = pos_2
        edge[[-1, maxim]] = edge[[maxim, -1]]

        return edge

    @staticmethod
    def find_edges(element, border, edge):
        where = np.sum(np.reshape(element, (3, 1)) == border, 1)
        many = np.sum(where)
        if many > 1:
            pos = np.where(where)[0]
            if edge[0, 0] == -1:
                edge[0, :] = element[pos]
            else:
                edge = np.vstack((edge, element[pos]))

        return edge

    def get_connections(self):
        return self.conn

    def get_points(self):
        return self.p

    def get_ne(self):
        return self.ne

    def get_np(self):
        return self.n_p

    def get_mesh(self):
        return self.x

    def plot_mesh(self):
        p = self.p
        conn = self.conn

        x = p[:, 0]
        y = p[:, 1]
        triplot(x, y, conn, color = 'blue')
        # for i in range(0, len(p)):
        #
        #     plt.annotate(i,
        #                  (p[i, 0], p[i, 1]),
        #                  size=15,
        #                  weight = 'bold',
        #                  textcoords="offset points",
        #                  xytext=(10, -7),
        #                  ha='center')
        plt.grid()
        plt.title('Mesh')

        plt.show()
        # plt.figure(figsize=(5, 5))


class Mesh1DRefinement(Mesh2D):

    def __init__(self, coarse_ne = 2, n_ref = 0):
        self.ne = coarse_ne
        self.np = coarse_ne + 1
        self.h = 1 / coarse_ne
        self.h = 1 / coarse_ne
        self.h = 1 / coarse_ne
        self.x = np.linspace(0, 1, self.np)
        self.conn = np.ndarray(shape=(self.ne, 2))
        self.n_ref = n_ref

    def construct(self):
        x = self.x
        ne = self.ne
        for i in range(0, self.n_ref):
            ne = ne * 2
        self.ne = ne
        self.np = ne + 1
        self.h = 1 / ne
        self.x = np.linspace(0, 1, self.np)
        self.conn = np.ndarray(shape=(self.ne, 2))
        super().connection_matrix()
